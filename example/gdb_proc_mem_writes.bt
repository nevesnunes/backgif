BEGIN { @pid = -1; @fd = -1; @is_mem_path = 0; }
tracepoint:syscalls:sys_exit_vfork / comm == "gdb"/ {
   if (args->ret != 0) {
       printf("%s: child pid=%d\n", comm, args->ret);
       @pid = args->ret;
   }
}
tracepoint:syscalls:sys_enter_openat /comm == "gdb"/ {
   // Given "/proc/$pid/task/$pid/mem", guess offset of "/mem",
   // where pid length is between 1 and 7.
   if (
       (strncmp(str(args->filename + 14), "/mem", 4) == 0) ||
       (strncmp(str(args->filename + 16), "/mem", 4) == 0) ||
       (strncmp(str(args->filename + 18), "/mem", 4) == 0) ||
       (strncmp(str(args->filename + 20), "/mem", 4) == 0) ||
       (strncmp(str(args->filename + 22), "/mem", 4) == 0) ||
       (strncmp(str(args->filename + 24), "/mem", 4) == 0) ||
       (strncmp(str(args->filename + 26), "/mem", 4) == 0)
   ) {
       // Parse pid after "/proc/".
       $i = 0;
       $candidate_pid = 0;
       while ($i <= 8) {
         $filename_ptr = (uint8*)(args->filename + $i + 6);
         $c = $filename_ptr[0];
         // Ordinal outside range of digit chars?
         if ($c < 48 || $c > 57) {
           break;
         }
         $candidate_pid = $candidate_pid * 10 + ($c - 48);
         $i++;
       }
       printf("%s: openat file=%s candidate pid=%d\n", comm, str(args->filename), $candidate_pid);

       // Inferior pid matched?
       if ($candidate_pid == @pid) {
           @is_mem_path = 1;
       }
   }
}
tracepoint:syscalls:sys_exit_openat /comm == "gdb" && @is_mem_path == 1/ {
   @fd = args->ret;
   @is_mem_path = 0;
}
tracepoint:syscalls:sys_enter_pwrite64 /comm == "gdb" && args->fd == @fd/ {
   printf("%s: write fd=%d buf=%r @ %08lx\n", comm, args->fd, buf(args->buf, args->count), args->pos);
}
